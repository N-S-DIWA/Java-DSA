//DFS Algorithm ->
////
//// In DFS We Use RECURSION ...
////
////class DFS{
////
////    private int V;
////    private LinkedList<Integer>[] adj;
////
////    public DFS(int V){
////        this.V = V;
////        adj = new LinkedList[V];
////
////        for(int i = 0; i < V; i++){
////            adj[i] = new LinkedList<>();
////        }
////    }
////
////    void addEdge(int v, int w){
////        adj[v].add(w);
////    }
////
////    void dfsRecursive (int v, boolean[] visited){
////        visited[v] = true;
////        System.out.print(v + " ");
////
////        for(int neighbour : adj[v]){
////            if(!visited[neighbour]){
////                dfsRecursive(neighbour, visited);
////            }
////        }
////    }
////

//      This is public DFS function:
//      It creates a visited array to keep track of which nodes are visited.
//      Then calls the recursive DFS starting from node start. -->

////    void DFS(int start){
////
////        boolean[] visited = new boolean[V];
////        dfsRecursive(start, visited);
////    }
////}
////
////public class Main{
////    public static void main(String[] args) {
////
////        DFS obj = new DFS(12);
////
////        obj.addEdge(0,1);
////        obj.addEdge(0,2);
////        obj.addEdge(1,3);
////        obj.addEdge(1,4);
////        obj.addEdge(2,5);
////        obj.addEdge(2,6);
////        obj.addEdge(3,7);
////        obj.addEdge(3,8);
////        obj.addEdge(4,9);
////        obj.addEdge(4,10);
////        obj.addEdge(6,11);
////
////        System.out.println("DFS Traversal ->");
////
////        obj.DFS(0);
////    }
////}